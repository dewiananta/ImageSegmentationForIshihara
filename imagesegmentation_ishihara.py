# -*- coding: utf-8 -*-
"""ImageSegmentation_ishihara.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cr-29Qr2AeuZe-OneIPDL1bpD_r0qaMF
"""

#Insert Input that will used
from scipy import ndimage as ndi # impot the necessary package fo watershed
from skimage.morphology import watershed, disk
from skimage import data,io
from skimage.filters import rank
from skimage.util import img_as_ubyte
from skimage.color import rgb2gray
import matplotlib.pyplot as plt
from skimage import filters #Operator sobel
from skimage.util import compare_images
import numpy as np

"""#1. Input Image"""

#Input image that will be implement a segmentation
img1 = io.imread("/content/ishihara test1.jpg") #open read image 
img2 = io.imread("/content/ishiaratest2.jpg") #open read image 
img3 = io.imread("/content/Ishihara-3.jpg") #open read image 

#Menampilkan Output
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(16,8))

axes[0].imshow(img1, cmap=plt.cm.gray)
axes[0].set_title('Image 1 Dengan 2 Angka  = 12')

axes[1].imshow(img2, cmap=plt.cm.gray)
axes[1].set_title('Image 2 Dengan 1 Nilai = 2')

for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

#Menampilkan Output
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(16,8))

axes[0].imshow(img3, cmap=plt.cm.gray)
axes[0].set_title('Image 3 Dengan Karakter')

for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

"""# 2. Pengubahan Image RGB To Grayscale

2.1 Ubah ke Grayscale dengan Tinting Graysacle
"""

from skimage import data
from skimage import color
from skimage import img_as_float


tinting1 = color.gray2rgb(img1)
tinting2 = color.gray2rgb(img2)
tinting3 = color.gray2rgb(img3)

#Membagi ke daerah bewarna merah dan kuning
red_multiplier = [1, 0, 0]
yellow_multiplier = [1, 1, 0]
#Implemnetasi Tinting Grayscale dengan mengkalikan original image dengan nilai tinting 
#Pada setiap warna
graytinting1 = red_multiplier * tinting1 #Citra 1 Merah
graytinting11 = yellow_multiplier * tinting1 #Citra 1 Kuning
graytinting2 = red_multiplier * tinting2 #Citra 2 Merah
graytinting22 = yellow_multiplier * tinting2 #Citra 2 Kuning
graytinting3 = red_multiplier * tinting3#Citra 3 Merah
graytinting33 = yellow_multiplier * tinting3 #Citra 3 Kuning



#Menampilkan Output
fig, axes = plt.subplots(ncols=4, sharex=True, sharey=True,
                         figsize=(20,8))

axes[0].imshow(graytinting1, cmap=plt.cm.gray)
axes[0].set_title('Image 1 Dengan 2 Angka  = 12 (red_multiplier)')

axes[1].imshow(graytinting11, cmap=plt.cm.gray)
axes[1].set_title('Image 1 Dengan 2 Angka  = 12 (yellow_multiplier)')


axes[2].imshow(graytinting2, cmap=plt.cm.gray)
axes[2].set_title('Image 2 Dengan 1 Nilai = 2 (red_multiplier)')

axes[3].imshow(graytinting22, cmap=plt.cm.gray)
axes[3].set_title('Image 2 Dengan 1 Nilai = 2 (yellow_multiplier')


for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(20,8))

axes[0].imshow(graytinting3, cmap=plt.cm.gray)
axes[0].set_title('Image 3 Dengan Karakter  (red_multiplier)')


axes[1].imshow(graytinting33, cmap=plt.cm.gray)
axes[1].set_title('Image 3 Dengan Karakter (yellow_multiplier)')


for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

"""2.2 Ubah RGB ke Grayscale Dasar"""

#(RGB To GRasysale)
grayscale1 = rgb2gray(img1) # for image 1
grayscale2 = rgb2gray(img2) #for image 2
grayscale3 = rgb2gray(img3) #for image 3
#Menampilkan Output
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(16,8))

axes[0].imshow(grayscale1, cmap=plt.cm.gray)
axes[0].set_title('Image 1 Dengan 2 Angka  = 12 | Graysacel')

axes[1].imshow(grayscale2, cmap=plt.cm.gray)
axes[1].set_title('Image 2 Dengan 1 Nilai = 2 |Graysacel')

for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(16,8))

axes[0].imshow(grayscale3, cmap=plt.cm.gray)
axes[0].set_title('Image 3 Dengan Karakter| Graysacel')
for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

"""#3. Edge Detection Dengan SOBEL Pada Gambar Grayscale Dasar"""

#Implemnetation Sobel Edge Dengan Gyascale Dasar (2 Dimensi)
edge_sobel1 = filters.sobel(grayscale1)# for image 1
edge_sobel2 = filters.sobel(grayscale2)# for image 2
edge_sobel3 = filters.sobel(grayscale3)# for image 3

#Output
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(16,8))

axes[0].imshow(edge_sobel1, cmap=plt.cm.gray)
axes[0].set_title("Sobel Detection Image 1 Dengan 2 nilai = 12 | Graysacel")

axes[1].imshow(edge_sobel2, cmap=plt.cm.gray)
axes[1].set_title('Sobel Detection Image 2 Dengan 1 Nilai = 2 | Grayscale')

for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(16,8))

axes[0].imshow(edge_sobel3, cmap=plt.cm.gray)
axes[0].set_title('Image 3 Dengan Karakter| Graysacel')
for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

"""#3. Implementasi HOG Descriptor Pada Image Yang Telah Di Grayscale Dasar Atapun Tinting Grayscale

#3.2 Implemnetasi HOG dengan Tinting Grayscale
"""

#Implemnentation HOG
from skimage.feature import hog #Lib menjalankan Histogram Orineted Gradient
from skimage import exposure #lib untuk merubah, mengetahui itensitas gambar
from skimage import exposure

#Implementation For Image 1 Original
fd1, hog_image1 = hog(graytinting1, orientations=9, pixels_per_cell=(8,8),block_norm='L2',
                    cells_per_block=(2,2), visualize=True,feature_vector=True,transform_sqrt=True)

#Gambar 2
fd, hog_image2 = hog(graytinting2, orientations=9, pixels_per_cell=(8,8),block_norm='L2',
                    cells_per_block=(2,2), visualize=True,feature_vector=True,transform_sqrt=True)

#Gambar 3
fd, hog_image3 = hog(graytinting3, orientations=9, pixels_per_cell=(8,8),block_norm='L2',
                    cells_per_block=(2,2), visualize=True,feature_vector=True,transform_sqrt=True)

# Logarithmic Menerangkan Cahayanya Gamma and log contrast adjustment
logarithmic_corrected1 = exposure.adjust_log(hog_image1, 2)
logarithmic_corrected2 = exposure.adjust_log(hog_image2, 2)
logarithmic_corrected3 = exposure.adjust_log(hog_image3, 1)

#Menampilakan Gamabr dari Yang setelah dilakukan HOG
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(10,5))

axes[0].imshow(logarithmic_corrected1, cmap=plt.cm.gray)
axes[0].set_title('HOG Image 1  Dengan Tinting Grayscale  ')

axes[1].imshow(logarithmic_corrected2, cmap=plt.cm.gray)
axes[1].set_title('HOG Image 2')


for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

#Menampilakan Gamabr dari Yang setelah dilakukan HOG
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(10,5))

axes[0].imshow(logarithmic_corrected3, cmap=plt.cm.gray)
axes[0].set_title('HOG Image 3  Dengan Tinting Grayscale  ')
for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

"""#3.2 Implementasi HOG dengan Edge SObel"""

#Implemnentation HOG
from skimage.feature import hog #Lib menjalankan Histogram Orineted Gradient
from skimage import exposure #lib untuk merubah, mengetahui itensitas gambar
from skimage import exposure

#Implementation For Image 1 Original
fd1, hog_image1 = hog(edge_sobel1, orientations=9, pixels_per_cell=(8,8),block_norm='L2',
                    cells_per_block=(2,2), visualize=True,feature_vector=True,transform_sqrt=True)

#Gambar 2
fd, hog_image2 = hog(edge_sobel2, orientations=9, pixels_per_cell=(8,8),block_norm='L2',
                    cells_per_block=(2,2), visualize=True,feature_vector=True,transform_sqrt=True)

#Gambar 3
fd, hog_image3 = hog(edge_sobel3, orientations=9, pixels_per_cell=(8,8),block_norm='L2',
                    cells_per_block=(2,2), visualize=True,feature_vector=True,transform_sqrt=True)

# Logarithmic Menerangkan Cahayanya Gamma and log contrast adjustment
logarithmic_corrected11 = exposure.adjust_log(hog_image1, 2)
logarithmic_corrected21 = exposure.adjust_log(hog_image2, 2)
logarithmic_corrected31 = exposure.adjust_log(hog_image3, 1)

#Menampilakan Gamabr dari Yang setelah dilakukan HOG
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(10,5))

axes[0].imshow(logarithmic_corrected11, cmap=plt.cm.gray)
axes[0].set_title('HOG Image 1 Dengan Sobel Detection   ')

axes[1].imshow(logarithmic_corrected21, cmap=plt.cm.gray)
axes[1].set_title('HOG Image 2 Dengan SObel Detection')


for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

#Menampilakan Gamabr dari Yang setelah dilakukan HOG
fig, axes = plt.subplots(ncols=2, sharex=True, sharey=True,
                         figsize=(10,5))

axes[0].imshow(logarithmic_corrected31, cmap=plt.cm.gray)
axes[0].set_title('HOG Image 3  Dengan Sobel Grayscale  ')
for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()

"""Dikarenakan hasil HOG dengan citra Tintin Grayscale mennghasilkan deteksi tepi yang lebih bagus maka untuk pemerosesan selanjutnya akan menggunakan citra yang sudah diterapkan HOG dengan tinting grayscale  sedangkan HoG dengan edge sobel tidak digunakan lagi

# 4. Pengimplemnetasian Median Filter Dan Segemntation Pada Setiap Citra
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import scipy.misc
import scipy.ndimage
import skimage.filters
import sklearn.metrics

"""# 4.1. Citra 1"""

#Implementasi Media FIlter Untuk Mengurangi noise citra

median_filtered1 = scipy.ndimage.median_filter(logarithmic_corrected1, size=3)
plt.imshow(median_filtered1, cmap='gray')
plt.axis('off')
plt.title('median filtered image')

#Menampilkan jenis segmentasi yang tersedia pada skimage filter untuk citra 1 
result = skimage.filters.thresholding.try_all_threshold(median_filtered1)

"""Dikarenakan hasil menggunakan implementasi Otsu atau Yen baik maka kita pilih menggunakan implementasi Otsu"""

thereshold1 = skimage.filters.threshold_otsu(median_filtered1)
print('Threshold value is {}'.format(thereshold1))
im_test1 = np.uint8(median_filtered1 > thereshold1) * 255
plt.imshow(im_test1, cmap='gray')
plt.axis('off')
plt.title('otsu predicted binary image')

"""#4.2. Citra 2"""

#Implementasi Media FIlter Untuk Mengurangi noise citra
median_filtered2 = scipy.ndimage.median_filter(logarithmic_corrected2, size=3)
plt.imshow(median_filtered2, cmap='gray')
plt.axis('off')
plt.title('median filtered image 2')

#Menampilkan jenis segmentasi yang tersedia pada skimage filter untuk citra 2
result = skimage.filters.thresholding.try_all_threshold(median_filtered2)

"""Dari gambar yang dihasilhkan hasil yang paling baik menggunakan segmentasi yen"""

thereshold2 = skimage.filters.threshold_yen(median_filtered2)
print('Threshold value is {}'.format(thereshold2))
im_test21 = np.uint8(median_filtered2 > thereshold2) * 255
plt.imshow(im_test21, cmap='gray')
plt.axis('off')
plt.title('yen predicted binary image')

"""#4.3 Citra 3"""

#Implementasi Media FIlter Untuk Mengurangi noise citra
median_filtered3 = scipy.ndimage.median_filter(logarithmic_corrected3, size=3)
plt.imshow(median_filtered3, cmap='gray')
plt.axis('off')
plt.title('median filtered image 3')

#Menampilkan jenis segmentasi yang tersedia pada skimage filter untuk citra 1 
result = skimage.filters.thresholding.try_all_threshold(median_filtered3)

#Penerapan treshold compact watershad
edges = sobel(median_filtered1)
im_test2 = watershed(edges, markers=468, compactness=0.001)

thereshold3 = skimage.filters.threshold_yen(median_filtered3)
print('Threshold value is {}'.format(thereshold3))
im_test31 = np.uint8(median_filtered3 > thereshold3) * 255
plt.imshow(im_test31, cmap='gray')
plt.axis('off')
plt.title('yen predicted binary image 3')

"""#5. Evaluasi Perbandingam Hasil Segmentasi Tresholding Pilihan Dengan Segmentasi Compact Watershad  Menggunakan Evaluasi Matriks

#5.1 Citra 1
"""

#Import Lib Yang Akan Digunakan Untuk Evaluasi Matriks
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage as ndi
from skimage import data
from skimage.metrics import (adapted_rand_error,
                              variation_of_information)
from skimage.filters import sobel
from skimage.measure import label
from skimage.util import img_as_float
from skimage.feature import canny
from skimage.morphology import remove_small_objects
from skimage.segmentation import (inverse_gaussian_gradient,
                                  watershed)

#True Image CItra 1
elevation_map = sobel(median_filtered1)
markers = np.zeros_like(median_filtered1)
markers[median_filtered1 < 30] = 1
markers[median_filtered1 > 150] = 2
im_true = watershed(elevation_map, markers)


#Compact Watershead
edges = sobel(median_filtered1)
im_test2 = watershed(edges, markers=468, compactness=0.001)

#Definisikan Evaluasi Untuk Citra 1
im_test2 = label(im_test2)
im_test1 = label(im_test1)
method_names = [ 'compact watershad', "Otsu Tresholding"]

precision_list = []
recall_list = []
split_list = []
merge_list = []
for name, im_test in zip(method_names, [ im_test2, im_test1]):
    error, precision, recall = adapted_rand_error(im_true, im_test)
    splits, merges = variation_of_information(im_true, im_test)
    split_list.append(splits)
    merge_list.append(merges)
    precision_list.append(precision)
    recall_list.append(recall)
    print(f"\n## Method: {name}")
    print(f"Adapted Rand error: {error}")
    print(f"Adapted Rand precision: {precision}")
    print(f"Adapted Rand recall: {recall}")
    print(f"False Splits: {splits}")
    print(f"False Merges: {merges}")

#Menampilkan Hasil Evaluasi Citra 1
fig, axes = plt.subplots(2, 2, figsize=(9, 6), constrained_layout=True)
ax = axes.ravel()

#True Image Citra 1
ax[1].imshow(mark_boundaries(median_filtered1, im_true))
ax[1].set_title('Gambar Sebelum Segemnetation')
ax[1].set_axis_off()
#Compact Watershed Citra 1
ax[2].imshow(mark_boundaries(median_filtered1, im_test2))
ax[2].set_title('Compact Watershed Citra 1')
ax[2].set_axis_off()

#Otsu Treshodling  1
ax[3].imshow(mark_boundaries(median_filtered1, im_test1))
ax[3].set_title('Otsu Treshodling  1')
ax[3].set_axis_off()

plt.show()

"""# 5.2 Citra 2"""

#True Image Citra 2
elevation_map = sobel(median_filtered2)
markers = np.zeros_like(median_filtered2)
markers[median_filtered2 < 30] = 1
markers[median_filtered2 > 150] = 2
im_true = watershed(elevation_map, markers)


#Compact Watershead Citra 2
edges = sobel(median_filtered2)
im_test2 = watershed(edges, markers=468, compactness=0.001)

#Inisialisai Untuk Melakukan Evaluasi Citra 2
im_test2 = label(im_test2)
im_test21 = label(im_test21)
method_names = [ 'compact watershad', "Yen Tresholding"]

precision_list = []
recall_list = []
split_list = []
merge_list = []
for name, im_test in zip(method_names, [ im_test2, im_test21]):
    error, precision, recall = adapted_rand_error(im_true, im_test)
    splits, merges = variation_of_information(im_true, im_test)
    split_list.append(splits)
    merge_list.append(merges)
    precision_list.append(precision)
    recall_list.append(recall)
    print(f"\n## Method: {name}")
    print(f"Adapted Rand error: {error}")
    print(f"Adapted Rand precision: {precision}")
    print(f"Adapted Rand recall: {recall}")
    print(f"False Splits: {splits}")
    print(f"False Merges: {merges}")

#Manampilkan Output Visualisasi Dari Evaluasi Matrik Citra 3
fig, axes = plt.subplots(2, 2, figsize=(9, 6), constrained_layout=True)
ax = axes.ravel()

#True Image Citra 2
ax[1].imshow(mark_boundaries(median_filtered2, im_true))
ax[1].set_title('Gambar Sebelum Segmentation Citra 2')
ax[1].set_axis_off()

#Yen Treshodling Citra 2
ax[2].imshow(mark_boundaries(median_filtered2, im_test21))
ax[2].set_title('Yen Treshodling Citra 2')
ax[2].set_axis_off()

#ompact Watershed Citra 2'
ax[3].imshow(mark_boundaries(median_filtered2, im_test2))
ax[3].set_title('Compact Watershed Citra 2')
ax[3].set_axis_off()

plt.show()

"""#5.3 Citra 3"""

#True Image Citra 3
elevation_map = sobel(median_filtered3)
markers = np.zeros_like(median_filtered3)
markers[median_filtered3 < 30] = 1
markers[median_filtered3 > 150] = 2
im_true = watershed(elevation_map, markers)


#Compact Watershead Citra 3
edges = sobel(median_filtered3)
im_test2 = watershed(edges, markers=468, compactness=0.001) 

#Label Inisialisasi Untuk Melakukan Evaluasi Matrik Citra 3
im_test2 = label(im_test2)
im_test31 = label(im_test31)
method_names = [ 'compact watershad Citra 3', "Yen Tresholding CItra 3"]

precision_list = []
recall_list = []
split_list = []
merge_list = []

for name, im_test in zip(method_names, [ im_test2, im_test31]):
    error, precision, recall = adapted_rand_error(im_true, im_test)
    splits, merges = variation_of_information(im_true, im_test)
    split_list.append(splits)
    merge_list.append(merges)
    precision_list.append(precision)
    recall_list.append(recall)
    print(f"\n## Method: {name}")
    print(f"Adapted Rand error: {error}")
    print(f"Adapted Rand precision: {precision}")
    print(f"Adapted Rand recall: {recall}")
    print(f"False Splits: {splits}")
    print(f"False Merges: {merges}")

#Visualisai  Output  Evaluasi Matriks Citra 3
fig, axes = plt.subplots(2, 2, figsize=(9, 6), constrained_layout=True)
ax = axes.ravel()

#True Image Citra 3
ax[1].imshow(mark_boundaries(median_filtered3, im_true))
ax[1].set_title('Gambar Sebelum Segmentasi Citra 3')
ax[1].set_axis_off()


#Yen Treshodling Citra 3 
ax[2].imshow(mark_boundaries(median_filtered3, im_test31))
ax[2].set_title('Yen Treshodling Citra 3')
ax[2].set_axis_off()

#Compact Watershed Citra 3
ax[3].imshow(mark_boundaries(median_filtered3, im_test2))
ax[3].set_title('Compact Watershed Citra 3')
ax[3].set_axis_off()

plt.show()

"""#Kode Diadaptasi Dari :
-	scipy.ndimage.median_filter — SciPy v1.6.0 Reference Guide
-	Evaluating segmentation metrics — skimage v0.19.0.dev0 docs (scikit-image.org)
-	Histogram of Oriented Gradients — skimage v0.19.0.dev0 docs (scikit-image.org)
-	scikit-image/thresholding.py at master • scikit-image/scikit-image • GitHub
-	Find Regular Segments Using Compact Watershed — skimage v0.19.0.dev0 docs (scikit-image.org)
-	Tinting gray-scale images — skimage v0.19.0.dev0 docs (scikit-image.org)
-	RGB to grayscale — skimage v0.19.0.dev0 docs (scikit-image.org)
-	Edge operators — skimage v0.19.0.dev0 docs (scikit-image.org)
-	Gamma and log contrast adjustment — skimage v0.18.0 docs (scikit-image.org)



"""